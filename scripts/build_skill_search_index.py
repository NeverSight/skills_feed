#!/usr/bin/env python3
"""
Build a searchable skill index with inlined English descriptions.

Input:
  - data/skills_index.json (generated by the crawler)
  - description_en.txt files already generated under data/skills-md/**/description_en.txt

Output:
  - data/skills_search_index.json

Design goals:
  - Fast lookup by id (map keyed by full skill id)
  - Deterministic output ordering for clean diffs
  - No external dependencies
"""

from __future__ import annotations

import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Optional

REPO_ROOT = Path(__file__).resolve().parent.parent
DATA_DIR = REPO_ROOT / "data"
INDEX_PATH = DATA_DIR / "skills_index.json"
OUTPUT_PATH = DATA_DIR / "skills_search_index.json"
FIRST_SEEN_PATH = DATA_DIR / "skills_first_seen.json"

# Safety cap: descriptions should be short, but avoid accidental huge payloads.
MAX_DESCRIPTION_CHARS = 5000


def _utc_now_iso() -> str:
    # Keep diffs smaller and consistent with other generated JSON in this repo.
    return datetime.now(timezone.utc).isoformat(timespec="seconds").replace("+00:00", "Z")


def _maybe_cn_path_from_en_path(repo_relative_path: Optional[str]) -> Optional[str]:
    """
    Given an English description path like:
      data/skills-md/<...>/description_en.txt
    return the sibling CN path:
      data/skills-md/<...>/description_cn.txt
    """
    if not repo_relative_path:
        return None
    s = str(repo_relative_path)
    if not s:
        return None
    if s.endswith("/description_en.txt"):
        return s[: -len("/description_en.txt")] + "/description_cn.txt"
    if s.endswith("\\description_en.txt"):
        return s[: -len("\\description_en.txt")] + "\\description_cn.txt"
    return None


def _load_first_seen_map() -> dict[str, str]:
    """
    Optional compatibility layer:
    - If `skills_index.json` items don't include `firstSeenAt` yet,
      we can still populate it from `data/skills_first_seen.json`.
    """
    if not FIRST_SEEN_PATH.exists():
        return {}
    try:
        data = json.loads(FIRST_SEEN_PATH.read_text(encoding="utf-8"))
        items = data.get("items") or {}
        if isinstance(items, dict):
            # Ensure values are strings (ISO timestamps).
            return {str(k): str(v) for k, v in items.items() if k and v}
    except Exception:
        pass
    return {}


def _read_text_repo_relative(repo_relative_path: Optional[str]) -> str:
    if not repo_relative_path:
        return ""
    rel = str(repo_relative_path).lstrip("/").strip()
    if not rel:
        return ""
    p = REPO_ROOT / rel
    try:
        return p.read_text(encoding="utf-8", errors="ignore")[:MAX_DESCRIPTION_CHARS].strip()
    except Exception:
        return ""


def _as_str(v: Any) -> str:
    if v is None:
        return ""
    if isinstance(v, str):
        return v
    return str(v)


def main() -> None:
    if not INDEX_PATH.exists():
        raise SystemExit(f"Missing {INDEX_PATH}. Run the crawler first.")

    index = json.loads(INDEX_PATH.read_text(encoding="utf-8"))
    items = index.get("items") or []
    if not isinstance(items, list):
        raise SystemExit("skills_index.json: expected `items` to be a list")

    first_seen_by_id = _load_first_seen_map()

    by_id: dict[str, dict[str, Any]] = {}

    for it in items:
        if not isinstance(it, dict):
            continue
        full_id = _as_str(it.get("id")).strip()
        if not full_id:
            continue

        description_en_path = it.get("description")
        desc_en = _read_text_repo_relative(description_en_path)

        # Optional CN translation (same folder, description_cn.txt).
        description_cn_path = _maybe_cn_path_from_en_path(description_en_path)
        desc_cn = _read_text_repo_relative(description_cn_path) if description_cn_path else ""

        first_seen_at = it.get("firstSeenAt") or first_seen_by_id.get(full_id)

        # Keep the payload small and query-friendly.
        by_id[full_id] = {
            "id": full_id,
            "providerId": it.get("providerId"),
            "source": it.get("source"),
            "skillId": it.get("skillId"),
            "title": it.get("title"),
            "link": it.get("link"),
            "firstSeenAt": first_seen_at,
            "installsAllTime": it.get("installsAllTime"),
            "installsTrending": it.get("installsTrending"),
            "installsHot": it.get("installsHot"),
            # Inline descriptions for searching.
            # Keep `description` as EN for backward compatibility.
            "description": desc_en,
            "descriptionEn": desc_en,
            "descriptionCn": desc_cn or None,
            # Keep paths for debugging / refresh verification.
            "descriptionPath": description_en_path,
            "descriptionEnPath": description_en_path,
            "descriptionCnPath": description_cn_path if desc_cn else None,
            "skillMdPath": it.get("skillMdPath"),
        }

    out = {
        "updatedAt": _utc_now_iso(),
        "sourceIndexUpdatedAt": index.get("updatedAt"),
        "version": 2,
        "count": len(by_id),
        "items": dict(sorted(by_id.items())),
    }

    OUTPUT_PATH.write_text(json.dumps(out, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
    print(f"Wrote {OUTPUT_PATH} ({len(by_id)} skills)")


if __name__ == "__main__":
    main()

