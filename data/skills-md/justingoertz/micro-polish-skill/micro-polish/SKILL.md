---
name: micro-polish
description: Apply invisible refinements that compound into felt quality
---

# Micro Polish

Apply obsessive attention to details others won't notice. The accumulated micro choices in typography, spacing, timing, and rhythm compound into a feeling of quality that registers subconsciously before it registers consciously.

## How to use

- `/micro-polish`
  Apply micro-refinement sensibility to any work in this conversation.

- `/micro-polish <file>`
  Review the file for micro-polish opportunities and output:
  - observation (quote the exact line/snippet)
  - why it matters (the felt difference)
  - a concrete refinement

## Philosophy

Quality emerges from hundreds of micro-decisions that individually seem insignificant but collectively create work that feels different—even when observers can't articulate why. This skill is about developing and trusting intuition for those choices.

## Understand the context

Before polishing, read the work and understand what it is and who it's for. Infer from the code or UI itself—file names, dependencies, existing patterns, visual language, and domain signals all reveal intent.

Different contexts demand different choices:

- A healthcare app for older users needs generous contrast, larger touch targets, and clarity over cleverness. "Subtle" would be a failure mode here.
- A luxury fashion site might prize restraint—quiet typography, refined spacing, atmosphere over accessibility. "Bold" might feel cheap.
- A developer CLI wants zero decoration. Polish means removing friction, not adding finesse.
- A children's game can be exuberant in ways that would feel juvenile elsewhere.

The same "refinement" can be right in one context and wrong in another. Maximum contrast is polish for an accessibility-first app. It's anti-polish for a meditation app. There are no universal rules—only appropriate choices for specific contexts.

When context is genuinely ambiguous and the right direction is unclear, ask. Otherwise, infer and proceed.

## Process

### Read the work slowly

Before changing anything, read the code or view the UI at half speed. Notice what creates friction. Notice what flows. Trust initial reactions before rationalizing them away.

### Notice what matters here

Given what this work is and who it's for, what does "polish" mean in this specific context? What would make this feel more like itself—more aligned with its purpose? Let that understanding guide which details deserve attention.

## What to output

After polishing, provide:

1. **Context understood** — What you inferred about the work and its users. What "polish" means here.
2. **Changes made** — Refinements applied, with the specific observation that prompted each.
3. **Rationale** — Why each choice fits *this* context. Not generic craft principles—the specific reasoning for this work.
4. **Left alone** — Details you noticed but chose not to change, and why they're right as-is for this context.

## Trust your eye

Some refinements can't be justified by rules. A 1px shift that makes an icon "sit right." A 50ms timing adjustment that makes motion "feel better." A color that's "not quite" the computed value but reads correctly.

These intuitions are valid. They come from accumulated exposure to quality work. Over time, you'll develop your own sense of what matters—and the confidence to override any guideline when your eye tells you otherwise.

Document your choices anyway—not to justify, but to build a vocabulary for what you're sensing.

## The standard

Polish until you can look at every part of the work and feel settled. Not excited, not proud—settled. The absence of small irritations. The quiet confidence that comes from knowing nothing was left approximate when it could have been precise.
